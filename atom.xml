<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jferroal&#39;s Blog</title>
  <subtitle>记录人生中不同的体验</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.jferroal.com/"/>
  <updated>2016-07-31T14:24:07.000Z</updated>
  <id>http://blog.jferroal.com/</id>
  
  <author>
    <name>Jferroal</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IntelliJ 相关配置</title>
    <link href="http://blog.jferroal.com/2016/07/30/IntelliJ-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.jferroal.com/2016/07/30/IntelliJ-相关配置/</id>
    <published>2016-07-31T01:41:06.000Z</published>
    <updated>2016-07-31T14:24:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作告一段落，一到周末就懒得要死，动也不想动，学习是没戏了，只能折腾一下工具玩了，，，  </p>
<hr>
<h2 id="IdeaVim"><a href="#IdeaVim" class="headerlink" title="IdeaVim"></a>IdeaVim</h2><p>虽然有配置好的 Vim，但是工作上还是离不开 IDE，，，<br>在 IntelliJ 上装了 Vim Emulator，挪了一些 vim 的配置过来，尽量保持操作一致吧。<br>配置 ideaVim 的步骤(Windows):  </p>
<ol>
<li>在 User\Username 目录下新建<code>.ideavimrc</code>文件    </li>
<li>编辑<code>.ideavimrc</code>文件，增加配置  </li>
</ol>
<pre><code>let mapleader = &quot;,&quot;  
let g:mapleader = &quot;,&quot;  

&quot; 快速保存    
nmap &lt;leader&gt;w :w!&lt;cr&gt;    

&quot; 快速退出    
nmap &lt;leader&gt;q :q!&lt;cr&gt;    

&quot; 修改 space 为搜索键    
map &lt;space&gt; /  
map &lt;c-space&gt; ?  

&quot; 修改 0 为 ^  
map 0 ^
</code></pre><p>参考的配置在<a href="https://github.com/amix/vimrc" target="_blank" rel="external">这里</a>，能配置的东西不多，而且也无法使用 vim 插件，只是为了尽量的做到和 vim 上的操作一致而已。  </p>
<h3 id="IntelliJ-快捷键"><a href="#IntelliJ-快捷键" class="headerlink" title="IntelliJ 快捷键"></a>IntelliJ 快捷键</h3><p>记录一些 IntelliJ 的快捷键，顺便熟悉一下功能吧 ~  </p>
<blockquote>
<ul>
<li>Find Usage: Alt + F7   </li>
<li>Quick Definition: Ctrl + Shift + I    </li>
<li>Jump To Source: Ctrl + Enter     </li>
<li>Jump To Navigation Bar: Alt + Home     </li>
<li>// Comment: Ctrl + /    </li>
<li>/**/ Comment: Ctrl + Shift + /    </li>
<li>Refactor This: Ctrl + Shift + Alt + I    </li>
<li>Rename: Shift + F6    </li>
<li>Change Signature:  Ctrl + F6  </li>
<li>Type Migration: Ctrl + Shift + F6    </li>
<li>Safe Delete: Alt + F6    </li>
<li>Variable: Ctrl + Alt + V  </li>
<li>Constant: Ctrl + Alt + C    </li>
<li>Method: Ctrl + Alt + M      </li>
<li>Inline: Ctrl + Alt + N    </li>
<li>Open Vim Emulator: Shift + Alt + V    </li>
<li>Check In Project: Ctrl + K    </li>
<li>Update Project: Ctrl + T      </li>
<li>Git Push: Shift + Ctrl + K      </li>
<li>Split Vertically: Ctrl + Alt + H – 和我的 ConEmu 快捷键保持一致  </li>
<li>Split Horizontally: Ctrl + Alt + J – 和我的 ConEmu 快捷键保持一致   </li>
<li>Go To Next Splitter: Alt + K  – 和我的 ConEmu 快捷键保持一致     </li>
<li>Sort Tab By Name: Shift + Ctrl + Alt + F5      </li>
<li>Show Git Annotation: Shift + Ctrl + Alt + F6        </li>
<li>Revert File:  Ctrl + Alt + Z      </li>
</ul>
</blockquote>
<h3 id="Live-Template-配置"><a href="#Live-Template-配置" class="headerlink" title="Live Template 配置"></a>Live Template 配置</h3><p>配置一些 Live Template 可以减少打字次数，延长键盘寿命 ~<br>在 IntelliJ 中增加 Live Template 的方法是:  </p>
<ol>
<li>将你想要设为 Live Template 的代码片段在 IntelliJ 中写下来并选中代码片段<br><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-731-IntelliJ-LiveTemplate-1.png" alt="step 1">  </li>
<li>选择菜单栏中的 Tools，在下拉菜单中选择<code>Save as Live Template</code><br><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-731-IntelliJ-LiveTemplate-2.png" alt="step 2">  </li>
<li>在弹出的框中编辑($…$ 中保存的值是 Live Template 中我们可以编辑的值，$END$ 只是变量填写完毕后光标的位置，存在 $Var$ 之后就可以通过<code>Edit variable</code>对变量的默认值等进行编辑)<br><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-731-IntelliJ-LiveTemplate-3.png" alt="step 3">  </li>
</ol>
<p>简单的例子:  </p>
<ol>
<li>插入 console.log 语句:<br> <img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-731-IntelliJ-LiveTemplate-Debug.png" alt="Debug"></li>
<li>插入 TODO 语句:<br> <img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-731-IntelliJ-LiveTemplate-TODO.png" alt="TODO"></li>
<li>Angular Service:<br> <img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-731-IntelliJ-LiveTemplate-Angular.png" alt="Angular Service"></li>
</ol>
<p>下载相应插件还会默认有一些配置好的 Live Template，比如 Angular 等。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作告一段落，一到周末就懒得要死，动也不想动，学习是没戏了，只能折腾一下工具玩了，，，  &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;IdeaVim&quot;&gt;&lt;a href=&quot;#IdeaVim&quot; class=&quot;headerlink&quot; title=&quot;IdeaVim&quot;&gt;&lt;/a&gt;IdeaVim
    
    </summary>
    
    
      <category term="IDE" scheme="http://blog.jferroal.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>配置 windows 下的命令行工具</title>
    <link href="http://blog.jferroal.com/2016/07/24/%E9%85%8D%E7%BD%AE-windows-%E4%B8%8B%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://blog.jferroal.com/2016/07/24/配置-windows-下的命令行工具/</id>
    <published>2016-07-24T20:02:37.000Z</published>
    <updated>2016-07-24T22:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于扛过了蛋疼的两周，据说接下就不会这么赶了，应该不会还这么忙碌吧，因为是据说，所以我整个人还是在一种不稳定的状态中的，就看明天 IPM 怎么说了。<br>最近这两周过的好蛋疼啊，要说是没有规律倒也不是，但是每天的规律就是赶工!嗯，不是进度慢效率低，我是真的尽力了，只是我一个人不能把所有的东西都搞定吧，而且还总有人在你后面哔哔哔，大家相互理解一下就好，真心累。<br>好在周五很顺利 ~ Nice  </p>
<hr>
<p>上周的时候是右边的嘴巴溃疡，这周是左边的嘴巴溃疡，而且位置都是那么尴尬，本来压力就大，寝食难安呐亲，据说漱口水会有用，也不知道真的假的，反正买回来试试 ~<br>我想吃好吃的:-(  </p>
<hr>
<p>希望下周能让我缓缓 ，，，  </p>
<hr>
<h2 id="蛋疼的-windows-命令行环境"><a href="#蛋疼的-windows-命令行环境" class="headerlink" title="蛋疼的 windows 命令行环境"></a>蛋疼的 windows 命令行环境</h2><p>作为一名专一的 Windows 用户，对于 Windows 的命令行环境实在有太多的槽可吐。<br>那么丑，不能自动补全，能用的命令太少，没有什么拓展性。<br>这就是 windows 下的命令行环境 – cmd。<br>为了摆脱这个蛋疼的 cmd，曾经也做过很多尝试:  </p>
<ol>
<li><a href="http://www.mingw.org/" target="_blank" rel="external">MinGw</a> &amp; <a href="https://www.cygwin.com/" target="_blank" rel="external">Cygwin</a><br>这两个东西是在 windows 平台上运行的 Unix 模拟环境，通过在 Windows 上配置这两个玩意我们可以在 Windows 下拥有 Unix 的工具。<br>之前只是稍微尝试过 MinGw，用 Cygwin 还是比较多的。这两个东西其实是有点蛋疼的:<br>首先，这两个东西相当于是要在系统中模拟另一个系统，因此他们的 size 必然不会小，随着你安装的东西越来越多，它们占用的地方也会越来越大，记得之前折腾的 Cygwin 占了好几个 G 的空间。<br>其次，如果只是为了追求一个类 Unix 的 Shell 环境，实在是没有必要折腾这些玩意。如果对 Linux<br>环境是刚需，折腾这中东西还是会有很多兼容性的问题，与其面对数之不尽的问题，还不如买个备用机装 Linux 好使，反正 Linux 对配置要求不高，花不了几个钱，何必浪费时间呢。  </li>
<li><a href="https://babun.github.io" target="_blank" rel="external">babun</a> &amp; <a href="https://github.com/bmatzelle/gow" target="_blank" rel="external">gow</a><br>babun 和 gow 也是人们为了解决在蛋疼的 Windows 命令行环境搞出来的东西，港真，本质上这两个东西和上面的那两个东西区别并不是很大，只是这两个东西并不是要在 Windows 下模拟 Linux 的环境，只是希望在 Windows 下能使用常用的 Linux 工具而已，因此这两个东西中包含了常见的 Linux Shell 工具，并且这些工具在 Windows 下是可以正常使用的，这样子人们就好像是在 Windows 下使用 Linux Shell 一样。<br>之前使用该一段时间的<code>Babun</code>，但是我没用多久就删了，删的原因是因为我觉的这东西还是太繁复，太过冗余，而且体验也没有真的在 Linux 环境下使用好，有的时候还有很多蛋疼的问题。  </li>
<li>Git Bash 等<br>如果电脑里安装了<a href="https://git-scm.com" target="_blank" rel="external">Git</a>，那么系统中就已经存在了<code>git bash</code>这样的利用 MinGw 实现的 Linux 模拟环境，Git Bash 的本质就是 MinGw，就不多说了，只是 Git Bash 中包含的只有一些常用的 Linux Shell 工具，所以体积没那么大，并且由于你并不会用它来干什么只有在 Linux 上可以做的事情，所以如果安安生生的还是可以用它来愉快的玩耍的。但是，如果你说它好丑啊，抱歉，无能为力 ~  </li>
</ol>
<h2 id="Powershell-gt-cmd"><a href="#Powershell-gt-cmd" class="headerlink" title="Powershell -&gt; cmd"></a>Powershell -&gt; cmd</h2><p>首先我们需要解决一下 cmd 功能缺失的问题，传统的 cmd 是 Dos 时代的遗物，但是到现在人们还在使用它，真心是很蛋疼。<br>早在 2006 年 MS 就已经开发了 Powershell，在 XP 上我们就已经可以用到 Powershell 了，我个人听说 Powershell 也是在上大学以后了。<br>关于 Powershell 是什么，可以参考 <a href="https://zh.wikipedia.org/wiki/Windows_PowerShell" target="_blank" rel="external">wikipedia</a>。<br>最开始使用 Powershell 的原因是:  </p>
<ol>
<li>能使用 ls / mv 等类 bash 的指令  </li>
<li>有比 cmd 更丰富的颜色(前提是直接打开 Powershell 而不是用 cmd 打开 Powershell)  </li>
</ol>
<p>其实我一开始也不知道 Powershell 很强大，，，只是正好上周还不忙的时候看到了之前收藏的 Page 想学习一下才发现的:-P<br>中文学习资料可以看<a href="http://www.pstips.net/powershell-online-tutorials/" target="_blank" rel="external">这里</a>  </p>
<h2 id="利用-ConEmu-增强-Windows-下的命令行环境"><a href="#利用-ConEmu-增强-Windows-下的命令行环境" class="headerlink" title="利用 ConEmu 增强 Windows 下的命令行环境"></a>利用 ConEmu 增强 Windows 下的命令行环境</h2><p><a href="https://conemu.github.io/" target="_blank" rel="external">ConEmu</a> 官方的说明是一个支持 Tab 的 Windows 控制台模拟器。不要被这么朴素的解释蒙蔽了，这货真心很强大，有了它你能在 Windows 感受到完全不一样的命令行环境。<br>之前也折腾过像 zsh 这样的 Shell 环境，通过不同的 Themes 和 Plugins，我们可以定制出属于我们的<code>好看</code>，<code>功能强大</code>的 Shell 环境。<br>通过 ConEmu 和 Powershell 我们也可以在 Windows 下实现像 zsh 那样的强大的 Shell 环境。<br>当我们安装好了 ConEmu 后，首先就会有一个默认的配置窗口让我们进行初始化的配置，上面的英文都不难，稍微看看就知道都有什么了，进行初步的配置后就会进入 ConEmu。<br>首先我们打开 Settings 进行必要的配置以便满足我们的需求:  </p>
<ol>
<li>Main<br><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-7-24-Setting-Main.png" alt="Main Setting"><br>在这里配置字体，字体大小，字符集等基本的东西，没什么复杂的，按自己喜欢的来就好。    </li>
<li>背景图片<br><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-7-24-Setting-Main-BackgroundImage.png" alt="Background Image"><br>这个功能我很喜欢呐，允许你为 Console 增加背景图片，结合一定的透明度，看起来还是很赞的 ~  </li>
<li>Tasks<br><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-7-24-Tasks.png" alt="Tasks"><br>这部分的设定包含了开启 ConEmu 时默认打开的程序，默认的设置成 Powershell 即可，其他的地方没什么好在意的。<br>最好在 Environment 中添加上一句<code>chcp utf8</code>修改默认编码集为 UTF8。  </li>
<li>Features<br><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-7-24-Color-Schema.png" alt="Features"><br>在这个部分里包含的都是一些显示上的自定义以及针对特殊 APP 的设定，我们只需要在意一下 Color 即可，通过这个选项我们可以修改我们的配色方案(当然你也可以自己配置，但是用别人的就可以啦 ~ )。<br>如果喜欢带透明度的界面到<code>Transparency</code>里设置一下就好。<br><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-7-24-Normal.png" alt="Normal">  </li>
<li>Keys &amp; Macro<br><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-7-24-Setting-Main.png" alt="Keys"><br>这个部分是非常重要的一个部分，通过在这里配置适合自己的键位，不仅能让我们对操作更加熟练，同时也是一个熟悉功能的过程。<br>对我而言有用的功能主要集中在下面这几项:  <ul>
<li>快速唤醒 – Alt + `    </li>
<li>新建窗口 – LAlt + E    </li>
<li>水平分割窗口 – LCtrl + LAlt + H   </li>
<li>垂直分割窗口 – LCtrl + LAlt + K   </li>
<li>向上移动窗口边界 – Win + LCtrl + H  </li>
<li>向下移动窗口边界 – Win + LCtrl + L     </li>
<li>向左移动窗口边界 – Win + LCtrl + J   </li>
<li>向右移动窗口边界 – Win + LCtrl + K   </li>
<li>选择左边的窗口 – LCtrl + LShift + J   </li>
<li>选择右边的窗口 – LCtrl + LShift + K  </li>
<li>选择左边的 Tab – LAlt + J   </li>
<li>选择右边的 Tab – LAlt + K   </li>
<li>关闭当前 Tab – LAlt + Q   </li>
<li>复制当前 Tab – LCtrl + Win + D  </li>
<li>在当前 Tab 中查找 – LCtrl + Win + F  </li>
</ul>
</li>
</ol>
<p>掌握了这些操作基本上就已经可以很好的操作 ConEmu 了。<br><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-7-24-split-windows.png" alt="Split Windows">  </p>
<h2 id="Powershell-插件"><a href="#Powershell-插件" class="headerlink" title="Powershell 插件"></a>Powershell 插件</h2><p>关于 Powershell 的插件，之前丝毫没有留意到，这两天折腾的时候才发现原来 Powershell 发展的还是很不错的，提供了很多非常实用的插件来提高我们的效率。<br>下面主要介绍几种我认为非常有用的 Powershell 插件:  </p>
<ol>
<li><a href="http://psget.net/" target="_blank" rel="external">PsGet</a><br>貌似在 Powershell 5.0 中已经内置了。<br>功能就相当于是 Debain 里的 apt-get，只不过用途是用来安装 Powershell 插件。具体的安装方法可以参考官方文档。  </li>
<li><a href="https://github.com/lzybkr/PSReadLine" target="_blank" rel="external">PSReadLine</a><br>这个在 Powershell 5.0 中应该是已经内置的了。<br>主要就是用来增强 Powershell 功能的。他能干什么在 Git Repo 中描述的很清楚，就不翻译了。  </li>
<li><a href="https://github.com/dahlbyk/posh-git" target="_blank" rel="external">Posh-Git</a><br>为 Powershell 提供 Git 集成。<br>参考知乎上的这个<a href="https://www.zhihu.com/question/29550357" target="_blank" rel="external">回答</a>。  </li>
<li><a href="https://github.com/tkellogg/Jump-Location" target="_blank" rel="external">Jump-Location</a><br>如果用过 zsh 那么一定知道 autojump，用 j 就能去任何地方简直爽爆了是吧，今天想看看 Powershell 有没有类似的东西，没想到还真有，试用了一下，感觉可以满足基本的使用，还是非常赞的。  </li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过使用 ConEmu 和 Powershell 我们就可以在 Windows 上使用强大的 Shell 环境里，同时利用 ConEmu 我们还可以同时将诸如<code>Git Bash</code>，<code>Babun</code>，<code>Putty</code>等在 ConEmu 中打开，这样子我们就可以打造一个非常 Nice 的命令行环境(我还在尝试的过程中 ~ )。<br><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-7-24-Vim.png" alt="Vim">  </p>
<p>PS. Vim(不是 Gvim)下无法输入中文的问题有人知道怎么搞么，解决不了真是蛋疼啊啊啊啊!   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于扛过了蛋疼的两周，据说接下就不会这么赶了，应该不会还这么忙碌吧，因为是据说，所以我整个人还是在一种不稳定的状态中的，就看明天 IPM 怎么说了。&lt;br&gt;最近这两周过的好蛋疼啊，要说是没有规律倒也不是，但是每天的规律就是赶工!嗯，不是进度慢效率低，我是真的尽力了，只是我一
    
    </summary>
    
    
      <category term="powershell" scheme="http://blog.jferroal.com/tags/powershell/"/>
    
      <category term="ConEmu" scheme="http://blog.jferroal.com/tags/ConEmu/"/>
    
      <category term="windows" scheme="http://blog.jferroal.com/tags/windows/"/>
    
      <category term="tools" scheme="http://blog.jferroal.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>我的 GTD | 2016-07</title>
    <link href="http://blog.jferroal.com/2016/07/10/%E6%88%91%E7%9A%84-GTD-2016-07/"/>
    <id>http://blog.jferroal.com/2016/07/10/我的-GTD-2016-07/</id>
    <published>2016-07-10T12:43:19.000Z</published>
    <updated>2016-07-10T14:02:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016-07-10 08:45:50<br>一直有在尝试时间管理，最近觉得似乎找到了一种适合自己的方式(感觉对了 ~ )。  </p>
<h3 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表"></a>工具列表</h3><h4 id="Wunderlist"><a href="#Wunderlist" class="headerlink" title="Wunderlist"></a><a href="https://www.wunderlist.com/zh/" target="_blank" rel="external">Wunderlist</a></h4><p>TODO List 应用:  </p>
<ul>
<li>制定计划/子任务  </li>
<li>任务提醒/同步 Calendar    </li>
<li>多平台支持</li>
<li>多用户协作</li>
<li>评论/Note/附件</li>
</ul>
<p>我觉得 Wunderlist 的制定计划的功能非常符合我的习惯，先制定 tasks list，然后再在 list 里面指定 task，每个 task 还可以有 subtask，在执行 task 的过程中还可以进行评论，记笔记等还是非常贴心的。<br>最开始是全部使用它作为时间管理的，但是后来发现自己根本就不习惯每天打开 Wunderlist 看，Android 的显示也不是很方便，在加上提醒功能我感觉不够好用，最终就只是拿来做计划用来，定期上去增加或者 Check Task 还是不错的 ~  </p>
<h4 id="Google-Calendar"><a href="#Google-Calendar" class="headerlink" title="Google Calendar"></a><a href="https://calendar.google.com/" target="_blank" rel="external">Google Calendar</a></h4><p>看看<a href="http://www.playpcesor.com/2014/10/10-google-calendar-tips.html" target="_blank" rel="external">电脑玩物</a>关于 Calendar 的博文可以更好的了解如何使用 Calendar 的使用，目前我只是用来规划日程而已，还需要更加深入的学习使用。<br>最开始因为手机的影梭无法使用，所以不用谷歌家的东西的，后来把手机弄好了就开始用了，一开始感觉并没有什么卵用，用到现在发现还是非常好用的(虽然 web 端的界面真的不好看)。<br>在手机上可以增加桌面小工具能非常直观的看到每天要做的事情，把其他应用的信息整合到日历中可以更快速的规划时间。  </p>
<h4 id="Pomotodo"><a href="#Pomotodo" class="headerlink" title="Pomotodo"></a><a href="https://pomotodo.com/" target="_blank" rel="external">Pomotodo</a></h4><p>如果你使用番茄工作法的话，这个应用还是非常有用的，在我看来，番茄工作法是:  </p>
<ol>
<li>提前制定工作计划  </li>
<li>遵循番茄时间({<strong>专心 25min</strong>/休息 5min} * 4/长休息 30min)  </li>
<li>定期回顾工作情况  </li>
</ol>
<p>番茄工作法应该是一种灵活的工作方式，如果死扣书本上的内容我觉得就违背了初心，我目前的工作方式是工作<strong>尽量</strong>专心工作 50min，休息 10min，两个番茄钟后长休息 30 min。<br>在我看来，只要我们能在工作的时候<strong>保持专注</strong>，那么时间的长度的是由我们掌控的，计划的制定不一定要按照书上说的在纸张上进行，我目前就是和其他工具一起使用。  </p>
<p>Pomoto 还是一款很不错的应用，之前只有 App 和 web 的时候不怎么爱用，现在 Desktop 版处理以后我还是蛮哈的，而且升级也不贵，看个人吧 ~  </p>
<h4 id="Google-Keep"><a href="#Google-Keep" class="headerlink" title="Google Keep"></a><a href="https://keep.google.com/" target="_blank" rel="external">Google Keep</a></h4><p>谷歌家的应用我感觉还是蛮好用的，Keep 的作用相当于是备忘录，支持录音/绘图/拍照等，能智能分类，也可以手动加标签，归档。在我看来，用 Google 家的东西，很大一部分原因是因为不同应用间的同步方便(如果越过了 wall)。</p>
<h3 id="时间粒度"><a href="#时间粒度" class="headerlink" title="时间粒度"></a>时间粒度</h3><p>最开始折腾 GTD 的时候，把时间粒度分得很细，后来发现对我来说简直是扯淡，因为思维比较跳跃，要是遇到感兴趣的事情立马就飞过去了，你让我完全照着计划走那不是做梦呢嘛，所以每次下定决心要好好 GTD 的结果都是无疾而终。<br>在不断调整的过程中，到现在大致上形成了一个<strong>对我来说</strong>比较合适的时间粒度。  </p>
<ol>
<li><p>长期计划<br>我认为要 GTD 如果没有计划是不可以接受的。计划，或者说目标是非常重要的东西，我们必须朝着一个固定的方向走才不至于迷路，因此花时间指定计划是非常重要的。<br>长期计划，长期的定义要看个人。<br>对我来说，超过一年的计划那都不是长期计划了，简直是超长期计划，这些计划我不会记录下来，因为不可知的因素太多，我都是记在心里的(你如果有详细到记不住的计划，我觉得你真的应该放空一下，万一变了你该多伤心，这样的东西只用来指引方向就好，千万别还没走一步就把十步都考虑了)。<br>所以我的长期计划一般就是年度计划 。。。。。。<br>真的就只有年度计划了~ ，再根据这些目标的不同类别，分别制定不同的年度计划。<br>这些计划实际上都是列表，可以随时增删的，千万不要太死板，定期检视年度计划的达成情况，在日常生活中，以年度计划为路线，有什么变动都直接显示到计划中。<br>在有了长期计划以后，可以根据长期计划每天实践。  </p>
</li>
<li><p>每日行程<br>每日行程主要是大致的规划每天要干的事情，并不会具体到要做什么。在一天中的各个时间段中分配不同类别的事物，一般来说在每周的开始就可以大概的制定这周需要进行的计划，然后根据计划一周内大致要做的事情其实是已经确定的，具体事务我觉得真的不是计划就能让你做的。  </p>
</li>
<li><p>工作时间<br>其实嘛，工作时间你想干什么呢，划水么，感觉是划不起来。在我看来，在办公室工作真的是一种很纠结的事情，因为在办公室工作是一种很没效率的事情(在我买了 QC20i 后有所改善)，因为你很容易被打断，这种感觉真的是糟透了，但是如果不在办公室工作，在交流上存在的问题真的很难搞，而且有问题的话就只能靠 Google 和 StackOverflow 而没办法问别人了。<br>所以在工作时间内我只能尝试<strong>尽力</strong>的番茄工作法，努力为自己营造一个不那么容易被打断的环境(因为老是不搭理同事被嫌弃了 。。。)。  </p>
</li>
<li><p>零碎时间<br>零碎时间真的是到处都是，上厕所，等待的时间，这些时间你可以做任何你想做的事情，反正我是不喜欢再吸收碎片知识，感觉并没有什么卵用。  </p>
</li>
</ol>
<h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><p>工具 + 时间粒度 = GTD Flow  </p>
<ol>
<li>每周<br>拥有长期计划的情况下，每周检视 Wunderlist 中的计划，整理计划，修改计划。  </li>
<li>每日<br>根据 Wunderlist 中的计划规划 Calendar 中的每日行程，每早检查 Calendar，修改行程，检查 Check list，安排每日具体事务。  </li>
<li>工作/碎片时间<br>使用 Pomotodo 实践番茄工作法，根据需求增加 potato。<br>将 Keep 作为日志使用，记录工作问题，突然的灵感，一些 list 之类的，可以善用提醒功能。  </li>
</ol>
<h3 id="啊呜"><a href="#啊呜" class="headerlink" title="啊呜 ~"></a>啊呜 ~</h3><p>当我把自己的 GTD 方法写下来的时候发现其实整个方法还是很模糊的，记录下来的同时也让我更清晰的了解到应该如何实践和改进，不知道下次再总结自己的 GTD 方法会是什么时候呢，下次再看的时候希望这个方法能变得更加适合自己 ~  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016-07-10 08:45:50&lt;br&gt;一直有在尝试时间管理，最近觉得似乎找到了一种适合自己的方式(感觉对了 ~ )。  &lt;/p&gt;
&lt;h3 id=&quot;工具列表&quot;&gt;&lt;a href=&quot;#工具列表&quot; class=&quot;headerlink&quot; title=&quot;工具列表&quot;&gt;&lt;/a&gt;工具
    
    </summary>
    
    
      <category term="GTD" scheme="http://blog.jferroal.com/tags/GTD/"/>
    
  </entry>
  
  <entry>
    <title>利用 Stripe API 进行支付</title>
    <link href="http://blog.jferroal.com/2016/07/09/%E5%88%A9%E7%94%A8-Stripe-API-%E8%BF%9B%E8%A1%8C%E6%94%AF%E4%BB%98/"/>
    <id>http://blog.jferroal.com/2016/07/09/利用-Stripe-API-进行支付/</id>
    <published>2016-07-09T18:01:03.000Z</published>
    <updated>2016-07-09T20:52:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第三方支付平台和-Stripe"><a href="#第三方支付平台和-Stripe" class="headerlink" title="第三方支付平台和 Stripe"></a>第三方支付平台和 Stripe</h3><p>对于某些网站应用，存在着支付功能的需求，如果从头开始实现一个完整的支付功能是不现实的，尤其对于创业型公司来说更是不可能的，不仅是时间与资金的问题，更多的是由于涉及到金钱，问题总会异常复杂。因此，更加快捷的方式是使用第三方支付平台提供的接口。<br>目前存在的一些第三方支付平台有:  </p>
<ol>
<li>Alipay  </li>
<li>Paypal  </li>
<li>Ping ++  </li>
<li>Stripe  </li>
<li>…  </li>
</ol>
<p>上面提到的几个平台，就我个人而言听说过的是 Alipay、Paypal、Ping ++，之前真的不知道还有 Stripe 这个东西 。。。<br>但是今天的主角就是 Stripe。第三方支付平台那么多，Stripe 有什么好呢？<br>最终要的一点是，Stripe 提供了支付宝的集成，这是非常非常重要的一个优点呐。<br>对我而言，如果需要购买一些外国服务，除了考虑性价比，很重要的一点是要看服务商支持的支付方式，如果支持支付宝付款对我来说真的是非常方便的(比如域名服务商 NameSilo 和 VPS 提供商搬瓦工就都支持支付宝付款)。<br>对于外国用户也是一样，如果国内的服务支持使用信用卡付款，那么他么肯定会觉得非常方便 ~<br>所以呢，这就是 Stripe 的优点了，只需要为网站集成 Stripe 的支付服务就可以同时应付国内和国外的支付需求。  </p>
<h3 id="Stripe-API-的使用与测试"><a href="#Stripe-API-的使用与测试" class="headerlink" title="Stripe API 的使用与测试"></a>Stripe API 的使用与测试</h3><p>港真，Stripe 的 API 真的灰常简单，Server 端所有的操作都是围绕着 Stripe API 中提供过的几种 Object 进行 operate 而已，真心没有什么难的。  </p>
<ol>
<li><a href="https://stripe.com/docs/api" target="_blank" rel="external">API 文档</a>  </li>
<li><a href="https://stripe.com/docs/examples" target="_blank" rel="external">官方例子</a>  </li>
</ol>
<p>只要能够看懂 Stripe 的文档，编写 Server 代码是完全没有任何问题的。<br>当我们实现了功能之后，必然需要测试一下功能，每一个第三方支付平台都会提供用于测试的 sandbox 环境，Stripe 当然也不例外。<br>对于测试 Stripe API，建立一个测试账号的方法是:  </p>
<ol>
<li>注册一个 Stripe 账号  </li>
<li>登录账号，进入 <a href="https://dashboard.stripe.com/test/dashboard" target="_blank" rel="external">dashboard</a>    </li>
<li>右上角 Your account -&gt; Account Setting -&gt; API Keys (请确保自己在 test 模式下)    </li>
</ol>
<p>然后我们就能获得测试用的 API Keys (测试时请选择前缀中为 test 的公私钥)进行测试了，测试中允许使用的卡的信息如下:  </p>
<blockquote>
<p>可以用来进行测试用的<a href="https://stripe.com/docs/testing" target="_blank" rel="external">测试卡</a>列表  </p>
</blockquote>
<p>如果是测试支付宝，那么 6 位的验证码输入 123456，身份证后六位输入 12345 就不会有问题了。<br>就我在学习的过程中发现的问题，不在于如何使用 API，而在于 Stripe 如何与系统集成在一起。下面，着重笔墨在如何 Stripe 与整合到你的网站中去。</p>
<h3 id="Stripe-提供的工具"><a href="#Stripe-提供的工具" class="headerlink" title="Stripe 提供的工具"></a>Stripe 提供的工具</h3><p>在使用中，我们会用到的 stripe 提供的东西有以下三种:  </p>
<ol>
<li><a href="https://stripe.com/docs/stripe.js" target="_blank" rel="external">stripe.js</a>   </li>
<li><a href="https://stripe.com/docs/checkout" target="_blank" rel="external">checkout.js</a>  </li>
<li><a href="https://stripe.com/docs/libraries" target="_blank" rel="external">stripe</a>    </li>
</ol>
<p>这三样东西是不同的，其中<code>1</code>/<code>2</code>用于<code>web</code>获取<code>stripeToken</code>，<code>3</code> 用于<code>server</code>执行各种各样的操作。<br>直接这么说恐怕大家还是很难理解。<br>首先我们要知道，用户的支付方式(信用卡信息，支付宝账户，银行账户等等)信息是非常敏感的信息，如果没有相关的资质，我们是绝对不应该保存用户的支付方式信息的。当涉及到肮脏的金钱交易时，知道的越少总是越好的 ~<br>因此，敏感的信息最好是不经我们手的，stripe.js 和 checkout.js 就是 Stripe 提供给我们的将敏感信息传递给他们的方法，所以呢:  </p>
<ol>
<li>stripe.js 和 checkout.js 是存在于 web 端的(从 <a href="https://js.stripe.com/v2/" target="_blank" rel="external">https://js.stripe.com/v2/</a> 处引入到页面中的)  </li>
<li>我们在页面中提供表单用于填写用户支付方式信息，然后使用 stripe.js 和 checkout.js 将这些信息传递给 Stripe  </li>
<li>我们将用户的支付方式提供给了 Stripe 之后，Stripe 进行相关的验证，并且返回一个 stripeToken 给我们  </li>
<li>我们可以使用这些<strong>一次性</strong>的 stripeToken 再进行支付等相关操作，而这些操作就是通过服务器端的 stripe 进行的啦  </li>
</ol>
<p>所以整体的样子应该是这样的:<br><a href="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/stripe%20%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B.png" target="_blank" rel="external">Stripe 工具关系</a>  </p>
<h4 id="stripe-js-和-checkout-js"><a href="#stripe-js-和-checkout-js" class="headerlink" title="stripe.js 和 checkout.js"></a>stripe.js 和 checkout.js</h4><p>stripe.js 的主要功能是一样的，我们通过这两个工具在 web 端获取 stripeToken。<br>stripe.js 只是 Stripe 提供给我们的用于获取 stripeToken 的工具，我们将支付方式信息交给 stripe.js，然后去做相关的事情，因此，使用 stripe.js 我们需要自己设计获取用户支付方式的表单，这是它的优点也是缺点。<br>我们利用 stripe.js 的 API 向 Stripe 发送请求，返回的 response.id 就是 stripeToken。后续的操作就是将 token 附加到请求中发送给 server 进行相关的操作。<br>引入 checkout.js 则会提供给我们一个现成的支付方式信息获取的表单，对这个表单我们只能控制输入项而无法决定表单的样式，这是它的缺点同时也是优点。<br>我们在设置 checkout.js 的表单的时候，需要提供一个回调函数，回调函数得到的参数是 token，和 args，我们需要在回调函数中将 token.id 传递给 server 进行相关的操作。<br>当然，stripe.js 和 checkout.js 最大的区别不止是否允许自定义表单样式，更重要的是如果需要使用支付宝的话，必须选择使用 checkout.js。因为 stripe.js 中是不提供<code>alipay_account</code>相关的操作的。<br>除了使用 stripe.js 和 checkout.js 获取 stripeToken 外，我们还可以使用 server 端的 stripe.tokens API 进行获取 stripeToken 的操作，但我个人不推荐这样的做法，因为使用这种方法的话，用户支付方式信息的传递就需要经过我们的 server，这样可能会存在安全责任，同时，这种方式并不支持 alipay。  </p>
<h4 id="server-的-stripe-API"><a href="#server-的-stripe-API" class="headerlink" title="server 的 stripe API"></a>server 的 stripe API</h4><p>前面已经说到，stripe 的 server API 非常简单，大致上可以归纳为:  </p>
<pre><code>stripe[object][action](param1[, param2], callback)
</code></pre><p>参数的个数主要是与<code>action</code>挂钩。<br>其中会使用到 web 传来的<code>stripeToken</code>的 object 和 action 主要有:  </p>
<ol>
<li>charges – create – source  </li>
<li>custoemrs – create – [source]  </li>
</ol>
<h3 id="站点内集成-Stripe-支付服务"><a href="#站点内集成-Stripe-支付服务" class="headerlink" title="站点内集成 Stripe 支付服务"></a>站点内集成 Stripe 支付服务</h3><p>本来这块想讲一下自己对于整套系统的见解，后来看到了标题，发现如果讲那些就跑偏了，删掉之前的话，接着讲讲本节的重点，在站点内集成 Stripe 支付服务。<br>如果仔细看了上面的内容，那么这节的内容应该非常容易理解。<br>首先集成分为两个部分，web 端和 server 端，其实如果不需要使用<code>支付宝</code>服务的话，实际上是可以在 web 端做什么的，但是个人不推荐这样的做法。<br>在 web 端我们: </p>
<ol>
<li>引入 stripe.js / checkout.js </li>
<li>为 stripe.js / checkout.js 设置公钥(从 dashboard 的 API Keys 中获取)  </li>
<li>增加支付方式/直接使用支付方式付款时将支付方式信息传给 Stripe 获取 stripeToken  </li>
<li>将获取到的 stripeToken 传递给 server  </li>
</ol>
<p>在 server 端我们:  </p>
<ol>
<li>引入 stripe lib  </li>
<li>设置 stripe 需要的私钥  </li>
<li>利用 stripe 提供的各种 API 进行操作  </li>
</ol>
<p>不涉及具体细节的集成过程就是这么简单，并没有任何复杂的地方。  </p>
<h3 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h3><p>其实在上面一节中要讲的东西基本上就已经讲完了，下面的使一些个人的想法:  </p>
<ol>
<li>公私密钥对是非常重要的东西，一定要以安全的方式保存  </li>
<li>能不持有的信息尽量不要持有  </li>
<li>支付服务中最重要的两个 Object 是 Customer 和 Charge，退款什么的 Stripe 的 Dashboard 就很不错了    </li>
<li>为每个用户都建立一个 Customer 是不需要 Token 的，增加 source 才需要  </li>
<li>如果有 Customer 了，通过 Customer 就可以完成 Charge 的建立，非常方便  </li>
<li>听说 Stripe 对移动端提供的 API 并不是非常友好呐 ~  </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第三方支付平台和-Stripe&quot;&gt;&lt;a href=&quot;#第三方支付平台和-Stripe&quot; class=&quot;headerlink&quot; title=&quot;第三方支付平台和 Stripe&quot;&gt;&lt;/a&gt;第三方支付平台和 Stripe&lt;/h3&gt;&lt;p&gt;对于某些网站应用，存在着支付功能的需
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.jferroal.com/tags/javascript/"/>
    
      <category term="stripe" scheme="http://blog.jferroal.com/tags/stripe/"/>
    
      <category term="alipay" scheme="http://blog.jferroal.com/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 Promise - 1</title>
    <link href="http://blog.jferroal.com/2016/06/26/%E8%B0%88%E8%B0%88-Promise/"/>
    <id>http://blog.jferroal.com/2016/06/26/谈谈-Promise/</id>
    <published>2016-06-27T01:35:46.000Z</published>
    <updated>2016-07-10T02:24:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天阳光明媚，万里无云呐，早上一直在弄 gvim 和 graphviz，弄到下午才弄完，本来想着做个饭就不出门了，但是因为要去最近的 citi bank ATM 机上 取钱，还是灰溜溜的爬出去了，一路上风景好赞呐，心花怒放的 ~<br>好多黑叔叔，吓死我了，还有尼玛说好的 citi bank 取款不要手续费呢，坑爹呢这是 !   </p>
<hr>
<p>原来 citi bank 早就不在 Boston 开设分行了，我特么的真的是呵呵哒了(2016-07-09 21:14:16)  </p>
<hr>
<p><img src="http://o72dm2udp.bkt.clouddn.com/blog/posts/image/2016-626-Wander.jpg" alt="beautiful buildings"><br>晚上回来用 graphviz 画了画图，过了过之前照着 copy 的<a href="https://github.com/then/promise/blob/master/src/core.js" target="_blank" rel="external">then/promise</a> 的 source code，翻译了部分 <a href="http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt1-theory-and-semantics" target="_blank" rel="external">Promise &amp; Deferred</a>，大致上也算是理解了 Promise 的含义<br>So，boys and girls，it’s time to 扯淡 ~  </p>
<h3 id="为什么要使用-Promise"><a href="#为什么要使用-Promise" class="headerlink" title="为什么要使用 Promise?"></a>为什么要使用 Promise?</h3><p>首先大家应该都知道 Javascript 是单线程并且异步 I/O 的。<br>举个例子，人们在医院里体检，分别要在各个不同的科室中进行检查，每一间科室不会等待某一位患者完成之前的检查并拒绝所有其他的用户，正确的行为是只要有能够检查的，就先让能检查的进行检查。<br>好绕口，感觉上面的例子不怎么好呢 … …<br>在<a href="https://www.zhihu.com/question/19732473" target="_blank" rel="external">知乎</a>上找了个还可以的解释，不知道能不能看懂:  </p>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调  </p>
</blockquote>
<p>要记住，老板不是只服务你一个人，在帮你找书的同时也会为其他顾客服务。<br>传统的 Javascript 的异步编程方法是回调 (callback)，意即在过程完成后调用 callback 函数处理返回结果，使用传统的 callback 方法，有可能会导致可怕的回调地狱(其实三角形看起来挺好看的吖:P):  </p>
<p><img src="http://image.slidesharecdn.com/promisesandchaininginangularjs-141027044455-conversion-gate02/95/promises-and-chaining-in-angularjs-into-callback-hell-and-back-again-17-638.jpg?cb=1414385382" alt="callback-hell"></p>
<p>使用 Promise 能够让我们用一种同步式的方法编写异步程序代码。    </p>
<h3 id="基础的-Promise-使用"><a href="#基础的-Promise-使用" class="headerlink" title="基础的 Promise 使用"></a>基础的 Promise 使用</h3><p>因为 Promise 是一种标准，因此我们只需要学习一种遵循标准的实现，基本上就能够使用大多数的 Promise 库了。<br>目前了解过的 Promise 的库主要有以下两个:  </p>
<ol>
<li><a href="https://github.com/kriskowal/q" target="_blank" rel="external">q</a>  </li>
<li><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">bluebird</a>  </li>
</ol>
<p>目前在使用的是 q，但是据说 bluebird 的效率更好 ~  </p>
<h4 id="将-callback-转化为-Promise"><a href="#将-callback-转化为-Promise" class="headerlink" title="将 callback 转化为 Promise"></a>将 callback 转化为 Promise</h4><pre><code>var promiseFunc = function () {
    var deferred = q.defer();
    fs.readFile(&quot;example.json&quot;, function (err, data) {
        if (err) {
            return deferred.reject(err);
        }
        return deferred.resolve(data);
    }
    return deferred.promise;
}
// - - -  
promiseFunc.then(function (data) {
    console.log(data);
};
</code></pre><h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><pre><code>var doSomeThing = function () {
    return promise0.then(function (data0) {
        var data1 = dealWithData(data0);
    }).then(function (data1) {
        var data2 = dealWithData(data1);
    }).then(function (data2) {
        // ...
    }).done(function () {
        // ... 
    });
}
</code></pre><h4 id="使用-all-批量处理不相干的-Promise"><a href="#使用-all-批量处理不相干的-Promise" class="headerlink" title="使用 all 批量处理不相干的 Promise"></a>使用 all 批量处理不相干的 Promise</h4><pre><code>var promises = [promise0, promise1, promise2, promise3];  
q.all(promise).then(function (promisesResult) {
    var promise0Result = promisesResult[0];
    var promise1Result = promisesResult[1];
    var promise2Result = promisesResult[2];
    var promise3Result = promisesResult[3];
});
</code></pre><h3 id="Promise-A-标准"><a href="#Promise-A-标准" class="headerlink" title="Promise/A+ 标准"></a>Promise/A+ 标准</h3><p><a href="https://promisesaplus.com/" target="_blank" rel="external">Promise/A+</a> 官方标准可以看这里，这里的<a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="external">翻译</a>也不错。<br>总的来说，有下面几点是需要注意的:  </p>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 是一个拥有 then 方法的对象或函数，当我们的 Promise 实现之后，then 方法会收到 Promise 的结果。<br>Promise 拥有三种状态:  </p>
<ol>
<li>Pending – 等待，状态迁移的起点  </li>
<li>Fulfilled – 完成，计算过程已经完成，计算结果已经确定  </li>
<li>Rejected – 拒绝，计算结果中断，中断的原因已经确定  </li>
</ol>
<h4 id="Then-方法"><a href="#Then-方法" class="headerlink" title="Then 方法"></a>Then 方法</h4><p>用于访问 Promise 的当前值，终止值以及失败原因。  </p>
<pre><code>promise.then(onFulfilled, onRejected)
</code></pre><ol>
<li>onFulfilled – 计算完毕后调用  </li>
<li>onRejected – 计算终止时调用  </li>
</ol>
<p>then 方法可以被同一个 Promise 调用多次。<br>then 方法最终必然会返回一个 Promise 对象。  </p>
<h4 id="Promise-解决过程"><a href="#Promise-解决过程" class="headerlink" title="Promise 解决过程"></a>Promise 解决过程</h4><p>Resolve 是一个抽象过程，有两个参数，一个是 Promise，另一个是值 x。<br>我们可以将 x 的状态(Promise Object)或者值交由 Promise 处理。  </p>
<h3 id="关于-Promise-的实现"><a href="#关于-Promise-的实现" class="headerlink" title="关于 Promise 的实现"></a>关于 Promise 的实现</h3><p>建议阅读一下<a href="https://www.promisejs.org/implementing/" target="_blank" rel="external">官方的指南</a>。<br>源码阅读可以读一下<a href="https://github.com/then/promise/blob/master/src/core.js" target="_blank" rel="external">then/promise</a>。  </p>
<p>一些基本的概念:  </p>
<blockquote>
<ul>
<li>Promise 表示<strong>还未知的值</strong>  </li>
<li>Deferred 表示<strong>还未完成的计算</strong>  </li>
</ul>
</blockquote>
<p>当你理解了 Promise 之后你会觉得上面这两个概念其实就已经能够概括 Promise 了，具体一点:  </p>
<blockquote>
<ol>
<li>Promise 是一个初始未知值的占位符  </li>
<li>Deferred 是产生未知值的计算过程  </li>
<li>Deferred 有一个 Promise 对象用来代表未来的结果  </li>
<li>调用者可以 resolve/reject 一个 Deferred  </li>
<li>Promise 本身可以被分配给多个消费者，并且每个消费者都会独立观察 Promise 的结果  </li>
<li>resolver 和 deferred 可以被分配给任意数量的生产者，并且 Promise 能够被第一个 resolve 处理  </li>
</ol>
</blockquote>
<p>用连续的语言形容一下，大概是这样子的：<br>我们有一个异步的过程 A，如果使用 Promise 的方式来处理这个异步过程，那么 A 会产生一个 Deferred - B，同时 B 中包含着一个 Promise - C，这个 C 代表的是 A 可能产生的结果，如果我们将 B 分配给另一个需要 A 产生数据的过程 D，那么当 B 的结果返回时，D 的就能够处理 C 的结果。</p>
<p>关于 Promise 的实现，有几点需要注意的是:  </p>
<ol>
<li>Promise 的本质是一个有限状态机(Pending, Fulfilled, Rejected)  </li>
<li>造成状态转移的方法有三种<code>fulfill</code>\<code>reject</code>\<code>resolve</code>，其中 resolve 是暴露给外界使用的  </li>
<li>then 方法必然是要返回一个 Promise 的  </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天阳光明媚，万里无云呐，早上一直在弄 gvim 和 graphviz，弄到下午才弄完，本来想着做个饭就不出门了，但是因为要去最近的 citi bank ATM 机上 取钱，还是灰溜溜的爬出去了，一路上风景好赞呐，心花怒放的 ~&lt;br&gt;好多黑叔叔，吓死我了，还有尼玛说好的 
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.jferroal.com/tags/javascript/"/>
    
      <category term="promise" scheme="http://blog.jferroal.com/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>OoPs ~</title>
    <link href="http://blog.jferroal.com/2016/05/12/hello-world/"/>
    <id>http://blog.jferroal.com/2016/05/12/hello-world/</id>
    <published>2016-05-13T01:43:26.000Z</published>
    <updated>2016-05-12T14:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>这绝对不是第一篇博客, 我只是讨厌荒凉而已. </p>
<p>我觉得就是一种奇怪的仪式感, 第一次总是要谨慎再谨慎. </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这绝对不是第一篇博客, 我只是讨厌荒凉而已. &lt;/p&gt;
&lt;p&gt;我觉得就是一种奇怪的仪式感, 第一次总是要谨慎再谨慎. &lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
